<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard – BinWatch</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet/dist/leaflet.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet/dist/leaflet.css" />
    <style>
        body {
            background-color: #f8f9fa;
        }
        .sidebar {
            height: 200vh;
            background-color: #198754;
            color: white;
            padding: 20px;
        }
        .sidebar a {
            color: white;
            text-decoration: none;
        }
        .sidebar a:hover {
            text-decoration: underline;
        }
        .content {
            padding: 20px;
        }
        #heatmap {
            height: 400px;
            margin-top: 20px;
        }
    </style>
</head>
<body>

<div class="d-flex">
    <!-- Sidebar -->
    <div class="sidebar">
        <h2 class="fw-bold">BinWatch</h2>
        <ul class="list-unstyled">
            <li><a href="index.html">Accueil</a></li>
            <li><a href="analyse.html">Analyse</a></li>
            <li><a href="tri.html">Recherche avancée</a></li>
            <li><a href="map.html">Carte</a></li>
            <li><a href="about.html">À propos</a></li>
            <li><a href="logout.html">Déconnexion</a></li>
        </ul>
    </div>

    <!-- Main Content -->
    <div class="content flex-grow-1">
        <h1 class="mb-4">Maire de : <span id="city"></span></h1>
        <h2 class="mb-4">Statistiques</h2>
        <div class="mb-4">
            <form id="dateFilterForm">
                <label for="startDate" class="form-label">Date de début :</label>
                <input type="date" id="startDate" class="form-control mb-2" required>
                <label for="endDate" class="form-label">Date de fin :</label>
                <input type="date" id="endDate" class="form-control mb-2" required>
                <button type="submit" class="btn btn-success">Filtrer</button>
            </form>
        </div>

        <!-- Graph: Evolution of analyzed bins -->
        <div class="mb-5">
            <h3>Évolution des poubelles analysées par jour</h3>
            <canvas id="binsChart" width="400" height="200"></canvas>
        </div>

        <!-- Heatmap: Critical points -->
        <div class="mb-5">
            <h3>Carte des points critiques</h3>
            <div id="heatmap"></div>
        </div>

        <div class="mb-4">
            <h3 id="todayTemperature" class="text-success"></h3>
        </div>
        <div class="mb-5">
            <h3>Diagramme de la température</h3>
            <canvas id="temperatureChart" width="400" height="200"></canvas>
        </div>
    </div>
</div>

<script>
    document.getElementById('city').textContent = sessionStorage.getItem('city') || 'Ville inconnue';

    const analysisHistory = JSON.parse(sessionStorage.getItem('analysisHistory')) || [];

    async function getCityCoordinates(city) {
        try {
            const response = await fetch(`https://nominatim.openstreetmap.org/search?city=${encodeURIComponent(city)}&format=json`);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            if (data.length > 0) {
                const lat = parseFloat(data[0].lat);
                const lon = parseFloat(data[0].lon);
                if (!isNaN(lat) && !isNaN(lon)) {
                    return [lat, lon];
                }
            }
            throw new Error('Invalid data received from API');
        } catch (error) {
            console.error('Error fetching city coordinates:', error);
            return [48.8566, 2.3522]; // Default to Paris
        }
    }

    async function getAddressCoordinates(address) {
        try {
            const response = await fetch(`https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(address)}&format=json`);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            if (data.length > 0) {
                const lat = parseFloat(data[0].lat);
                const lon = parseFloat(data[0].lon);
                if (!isNaN(lat) && !isNaN(lon)) {
                    return [lat, lon];
                }
            }
            throw new Error('Invalid data received from API');
        } catch (error) {
            console.error('Error fetching address coordinates:', error);
            return null; // Return null if the address cannot be resolved
        }
    }

    function calculateColor(count) {
        if (count === 1) return '#FFFF00'; // Yellow for 1 report
        if (count === 2) return '#FFCC00'; // Orange-yellow for 2 reports
        if (count === 3) return '#FF9900'; // Orange for 3 reports
        if (count === 4) return '#FF6600'; // Red-orange for 4 reports
        return '#FF0000'; // Red for 5 or more reports
    }

    function calculateRadius(count) {
        return 50 + count * 20; // Base radius + dynamic increase
    }

    async function initializeHeatmap() {
        const city = sessionStorage.getItem('city') || 'Paris'; // Default to Paris
        const coordinates = await getCityCoordinates(city);

        if (!coordinates || coordinates.some(coord => isNaN(coord))) {
            console.error('Invalid coordinates, using fallback.');
            return;
        }

        const heatmap = L.map('heatmap').setView(coordinates, 13); // Adjust zoom level for better readability
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors'
        }).addTo(heatmap);

        const locationCounts = {}; // Count occurrences of each location
        for (const { location } of analysisHistory) {
            if (location) {
                locationCounts[location] = (locationCounts[location] || 0) + 1;
            }
        }

        for (const location in locationCounts) {
            let latLng = location.split(',').map(Number); // Check if it's already lat,lng format
            if (latLng.some(isNaN)) {
                latLng = await getAddressCoordinates(location); // Convert address to lat,lng
            }
            if (latLng && !latLng.some(isNaN)) {
                const count = locationCounts[location];
                const radius = calculateRadius(count);
                const color = calculateColor(count);

                L.circle(latLng, {
                    radius: radius,
                    color: color,
                    weight: 1, // Smaller border
                    fillOpacity: 0.7
                }).addTo(heatmap);
            } else {
                console.warn('Invalid location data:', location);
            }
        }
    }

    function filterDataByDateRange(data, startDate, endDate) {
        return data.filter(({ date }) => date >= startDate && date <= endDate);
    }
    let binsChartInstance = null;

    function updateBinsChart(filteredData) {
        const binsPerDay = {};
        filteredData.forEach(({ date }) => {
            binsPerDay[date] = (binsPerDay[date] || 0) + 1;
        });

        const sortedDates = Object.keys(binsPerDay).sort((a, b) => new Date(a) - new Date(b));
        const sortedBins = sortedDates.map(date => binsPerDay[date]);

        const binsChartCtx = document.getElementById('binsChart').getContext('2d');

        // Destroy the existing chart instance if it exists
        if (binsChartInstance) {
            binsChartInstance.destroy();
        }

        binsChartInstance = new Chart(binsChartCtx, {
            type: 'line',
            data: {
                labels: sortedDates,
                datasets: [{
                    label: 'Bacs analysés',
                    data: sortedBins,
                    borderColor: 'rgba(255, 99, 132, 1)',
                    backgroundColor: 'rgba(255, 99, 132, 0.2)',
                }]
            },
            options: {
                responsive: true,
                scales: {
                    x: { title: { display: true, text: 'Date' } },
                    y: { title: { display: true, text: 'Nombre de bacs' } }
                }
            }
        });
    }
    let heatmapInstance = null;

    async function updateHeatmap(filteredData) {
        // Check if the map instance exists and remove it
        if (heatmapInstance) {
            heatmapInstance.remove();
            heatmapInstance = null; // Reset the instance
        }

        // Initialize a new map instance
        heatmapInstance = L.map('heatmap').setView([48.8566, 2.3522], 13); // Default to Paris
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors'
        }).addTo(heatmapInstance);

        const locationCounts = {};
        filteredData.forEach(({ location }) => {
            locationCounts[location] = (locationCounts[location] || 0) + 1;
        });

        for (const location in locationCounts) {
            const [lat, lon] = await getAddressCoordinates(location);
            if (!isNaN(lat) && !isNaN(lon)) {
                L.circle([lat, lon], {
                    color: 'red',
                    radius: locationCounts[location] * 100
                }).addTo(heatmapInstance);
            }
        }
    }

    document.getElementById('dateFilterForm').addEventListener('submit', async (e) => {
        e.preventDefault();
        const startDate = document.getElementById('startDate').value;
        const endDate = document.getElementById('endDate').value;

        const filteredData = filterDataByDateRange(analysisHistory, startDate, endDate);

        updateBinsChart(filteredData);
        await updateHeatmap(filteredData);
    });

    window.addEventListener('load', async () => {
        updateBinsChart(analysisHistory);
        await initializeHeatmap();
    });

    let temperatureChartInstance = null;

    // Function to fetch and display today's temperature
    async function displayTodayTemperature() {
        const city = sessionStorage.getItem('city') || 'Paris'; // Default to Paris
        const coordinates = await getCityCoordinates(city);

        if (!coordinates || coordinates.some(coord => isNaN(coord))) {
            console.error('Invalid coordinates, using fallback.');
            return;
        }

        try {
            const response = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${coordinates[0]}&longitude=${coordinates[1]}&hourly=temperature_2m&timezone=auto`);
            const data = await response.json();

            const today = new Date().toISOString().split('T')[0];
            const todayTemperatures = data.hourly.temperature_2m.slice(0, 24); // First 24 hours for today

            document.getElementById('todayTemperature').textContent = `Température d'aujourd'hui: ${todayTemperatures[0]}°C`;
        } catch (error) {
            console.error('Error fetching temperature data:', error);
        }
    }

    // Function to update the temperature chart
    async function updateTemperatureChart(filteredData) {
        const temperaturePerHour = {};
        filteredData.forEach(({ time, temperature }) => {
            temperaturePerHour[time] = temperature;
        });

        const sortedTimes = Object.keys(temperaturePerHour).sort((a, b) => new Date(a) - new Date(b));
        const sortedTemperatures = sortedTimes.map(time => temperaturePerHour[time]);

        const temperatureChartCtx = document.getElementById('temperatureChart').getContext('2d');

        // Destroy the existing chart instance if it exists
        if (temperatureChartInstance) {
            temperatureChartInstance.destroy();
        }

        temperatureChartInstance = new Chart(temperatureChartCtx, {
            type: 'line',
            data: {
                labels: sortedTimes,
                datasets: [{
                    label: 'Température (°C)',
                    data: sortedTemperatures,
                    borderColor: 'rgba(54, 162, 235, 1)',
                    backgroundColor: 'rgba(54, 162, 235, 0.2)',
                }]
            },
            options: {
                responsive: true,
                scales: {
                    x: { title: { display: true, text: 'Heure' } },
                    y: { title: { display: true, text: 'Température (°C)' } }
                }
            }
        });
    }

    // Event listener for the filter form
    document.getElementById('dateFilterForm').addEventListener('submit', async (e) => {
        e.preventDefault();
        const startDate = document.getElementById('startDate').value;
        const endDate = document.getElementById('endDate').value;

        const city = sessionStorage.getItem('city') || 'Paris'; // Default to Paris
        const coordinates = await getCityCoordinates(city);

        if (!coordinates || coordinates.some(coord => isNaN(coord))) {
            console.error('Invalid coordinates, using fallback.');
            return;
        }

        try {
            const response = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${coordinates[0]}&longitude=${coordinates[1]}&hourly=temperature_2m&timezone=auto`);
            const data = await response.json();

            const filteredData = data.hourly.time.map((time, index) => ({
                time,
                temperature: data.hourly.temperature_2m[index]
            })).filter(({ time }) => time >= `${startDate}T00:00` && time <= `${endDate}T23:59`);

            await updateTemperatureChart(filteredData);
        } catch (error) {
            console.error('Error fetching temperature data:', error);
        }
    });

    // On page load, display today's temperature
    window.addEventListener('load', async () => {
        await displayTodayTemperature();
    });
</script>
</body>
</html>