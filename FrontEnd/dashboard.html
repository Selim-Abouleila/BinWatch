<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard – BinWatch</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet/dist/leaflet.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet/dist/leaflet.css" />
    <style>
        body {
            background-color: #f8f9fa;
        }
        .sidebar {
            height: 400vh;
            background-color: #198754;
            color: white;
            padding: 15px;
        }
        .sidebar a {
            color: white;
            text-decoration: none;
            font-size: 0.9rem;
        }
        .sidebar a:hover {
            text-decoration: underline;
        }
        .content {
            padding: 15px;
        }
        #heatmap {
            height: 300px;
            margin-top: 15px;
        }
        .table {
            font-size: 0.85rem;
        }
        h1, h2, h3 {
            font-size: 1.25rem;
        }
        .btn {
            font-size: 0.85rem;
            padding: 5px 10px;
        }
        .form-control {
            font-size: 0.85rem;
            padding: 5px;
        }
        .thumbnail {
            max-height: 40px;
        }
        div{
            margin-bottom: 15px;
        }
    </style>
</head>
<body>

<div class="d-flex">
    <!-- Sidebar -->
    <div class="sidebar">
        <a href="index.html"><h2 class="fw-bold fs-5">BinWatch</h2></a>
        <ul class="list-unstyled">
            <li><a href="index.html">Accueil</a></li>
            <li><a href="analyse.html">Analyse</a></li>
            <li><a href="tri.html">Recherche avancée</a></li>
            <li><a href="map.html">Carte</a></li>
            <li><a href="about.html">À propos</a></li>
            <li><a href="logout.html">Déconnexion</a></li>
        </ul>
    </div>

    <!-- Main Content -->
    <div class="content flex-grow-1">
        <h1 class="mb-3">Maire de : <span id="city"></span></h1>
        <h2 class="mb-3">Statistiques</h2>
        <div class="mb-3">
            <button id="addBinsButton" class="btn btn-success">Ajouter 50 poubelles à Lyon (Bouton d'exemple)</button>
        </div>
        <div class="d-inline-block p-2 bg-success text-white rounded">
            <span id="resolvedBinsCount" class="fw-bold fs-5">0</span>
            <small>Poubelles résolues</small>
        </div>
        <div class="mb-3">
            <form id="dateFilterForm" class="row g-2">
                <div class="col">
                    <input type="date" id="startDate" class="form-control" required>
                </div>
                <div class="col">
                    <input type="date" id="endDate" class="form-control" required>
                </div>
                <div class="col-auto">
                    <button type="submit" class="btn btn-success">Filtrer</button>
                </div>
            </form>
        </div>
        <div id="filterTagContainer" class="mb-3"></div>
        <!-- Graph: Evolution of analyzed bins -->
        <div class="container">
            <!-- Row for two charts side by side -->
            <div class="row mb-4">
                <div class="col-md-6">
                    <h3>Évolution des poubelles analysées</h3>
                    <canvas id="binsChart" width="300" height="300"></canvas>
                </div>
                <div class="col-md-6">
                    <h3>Répartition des poubelles analysées</h3>
                    <canvas id="binsPieChart" width="300" height="150"></canvas>
                </div>
            </div>

            <!-- Row for the heatmap -->
            <div class="row">
                <div class="col-12">
                    <h3>Carte des points critiques</h3>
                    <div id="heatmap"></div>
                </div>
            </div>
        </div>

        <div class="mb-4">
            <h3>Gestion des poubelles en traitement</h3>
            <table class="table table-bordered table-hover">
                <thead class="table-success">
                <tr>
                    <th>Miniature</th>
                    <th>Date</th>
                    <th>Annotation</th>
                    <th>Localisation</th>
                    <th>Statut</th>
                    <th>Action</th>
                </tr>
                </thead>
                <tbody id="processingBinsTable"></tbody>
            </table>
        </div>
    </div>
</div>

<script>
    document.getElementById('city').textContent = sessionStorage.getItem('city') || 'Ville inconnue';

    const analysisHistory = JSON.parse(sessionStorage.getItem('analysisHistory')) || [];

    async function getCityCoordinates(city) {
        try {
            const response = await fetch(`https://nominatim.openstreetmap.org/search?city=${encodeURIComponent(city)}&format=json`);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            if (data.length > 0) {
                const lat = parseFloat(data[0].lat);
                const lon = parseFloat(data[0].lon);
                if (!isNaN(lat) && !isNaN(lon)) {
                    return [lat, lon];
                }
            }
            throw new Error('Invalid data received from API');
        } catch (error) {
            console.error('Error fetching city coordinates:', error);
            return [48.8566, 2.3522]; // Default to Paris
        }
    }

    async function getAddressCoordinates(address) {
        try {
            const response = await fetch(`https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(address)}&format=json`);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            if (data.length > 0) {
                const lat = parseFloat(data[0].lat);
                const lon = parseFloat(data[0].lon);
                if (!isNaN(lat) && !isNaN(lon)) {
                    return [lat, lon];
                }
            }
            throw new Error('Invalid data received from API');
        } catch (error) {
            console.error('Error fetching address coordinates:', error);
            return null; // Return null if the address cannot be resolved
        }
    }

    function calculateColor(count) {
        if (count === 1) return '#FFFF00'; // Yellow for 1 report
        if (count === 2) return '#FFCC00'; // Orange-yellow for 2 reports
        if (count === 3) return '#FF9900'; // Orange for 3 reports
        if (count === 4) return '#FF6600'; // Red-orange for 4 reports
        return '#FF0000'; // Red for 5 or more reports
    }

    function calculateRadius(count) {
        return 50 + count * 20; // Base radius + dynamic increase
    }

    async function initializeHeatmap() {
        const city = sessionStorage.getItem('city') || 'Paris'; // Default to Paris
        const coordinates = await getCityCoordinates(city);

        if (!coordinates || coordinates.some(coord => isNaN(coord))) {
            console.error('Invalid coordinates, using fallback.');
            return;
        }

        const heatmap = L.map('heatmap').setView(coordinates, 13); // Adjust zoom level for better readability
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors'
        }).addTo(heatmap);

        // Define a modern custom icon
        const modernIcon = L.icon({
            iconUrl: 'https://cdn-icons-png.flaticon.com/128/684/684809.png', // Example modern icon
            iconSize: [40, 40], // Icon size [width, height]
            iconAnchor: [20, 40], // Anchor point of the icon [x, y]
            popupAnchor: [0, -40] // Position of the popup relative to the icon [x, y]
        });

        const locationCounts = {}; // Count occurrences of each location
        for (const { location } of analysisHistory) {
            if (location) {
                locationCounts[location] = (locationCounts[location] || 0) + 1;
            }
        }

        for (const location in locationCounts) {
            let latLng = location.split(',').map(Number); // Check if it's already lat,lng format
            if (latLng.some(isNaN)) {
                latLng = await getAddressCoordinates(location); // Convert address to lat,lng
            }
            if (latLng && !latLng.some(isNaN)) {
                const count = locationCounts[location];
                const radius = calculateRadius(count);
                const color = calculateColor(count);

                // Add circle for density
                L.circle(latLng, {
                    radius: radius,
                    color: color,
                    weight: 1, // Smaller border
                    fillOpacity: 0.7
                }).addTo(heatmap);

                // Add modern marker for precise location
                L.marker(latLng, { icon: modernIcon })
                    .addTo(heatmap)
                    .bindPopup(`<strong>${location}</strong><br>Occurrences: ${count}`);
            } else {
                console.warn('Invalid location data:', location);
            }
        }
    }
    function filterDataByDateRange(data, startDate, endDate) {
        return data.filter(({ date }) => date >= startDate && date <= endDate);
    }
    let binsChartInstance = null;

    function updateBinsChart(filteredData) {
        const binsPerDay = {};
        filteredData.forEach(({ date }) => {
            binsPerDay[date] = (binsPerDay[date] || 0) + 1;
        });

        const sortedDates = Object.keys(binsPerDay).sort((a, b) => new Date(a) - new Date(b));
        const sortedBins = sortedDates.map(date => binsPerDay[date]);

        const binsChartCtx = document.getElementById('binsChart').getContext('2d');

        // Destroy the existing chart instance if it exists
        if (binsChartInstance) {
            binsChartInstance.destroy();
        }

        binsChartInstance = new Chart(binsChartCtx, {
            type: 'line',
            data: {
                labels: sortedDates,
                datasets: [{
                    label: 'Poubelles analysés',
                    data: sortedBins,
                    borderColor: 'rgba(255, 99, 132, 1)',
                    backgroundColor: 'rgba(255, 99, 132, 0.2)',
                }]
            },
            options: {
                responsive: true,
                scales: {
                    x: { title: { display: true, text: 'Date' } },
                    y: { title: { display: true, text: 'Nombre de Poubelles' } }
                }
            }
        });
    }

    document.getElementById('dateFilterForm').addEventListener('submit', async (e) => {
        e.preventDefault();
        const startDate = document.getElementById('startDate').value;
        const endDate = document.getElementById('endDate').value;

        const filteredData = filterDataByDateRange(analysisHistory, startDate, endDate);

        if (Array.isArray(filteredData)) {
            updateBinsChart(filteredData);
            updateBinsPieChart(filteredData);

            // Add filter tag
            const filterTagContainer = document.getElementById('filterTagContainer');
            filterTagContainer.innerHTML = `
            <button class="btn btn-outline-success btn-sm">
                ${startDate} à ${endDate} <span class="ms-2 text-danger" style="cursor: pointer;">&times;</span>
            </button>
        `;

            // Add event listener to remove filter
            filterTagContainer.querySelector('span').addEventListener('click', async () => {
                filterTagContainer.innerHTML = '';
                const form = document.getElementById('dateFilterForm');
                form.reset();
                updateBinsChart(analysisHistory);
                updateBinsPieChart(analysisHistory);
            });
        } else {
            console.error('Filtered data is not an array:', filteredData);
        }
    });

    window.addEventListener('load', async () => {
        updateBinsChart(analysisHistory);
        await initializeHeatmap();
    });
    document.getElementById('addBinsButton').addEventListener('click', () => {
        const history = JSON.parse(sessionStorage.getItem('analysisHistory')) || [];
        const today = new Date();

        // Predefined random locations in Lyon
        const locations = [
            'Place Bellecour, Lyon',
            'Parc de la Tête d\'Or, Lyon',
            'Rue de la République, Lyon',
            'Confluence, Lyon',
            'Vieux Lyon, Lyon',
            'Part-Dieu, Lyon',
            'Fourvière, Lyon',
            'Guillotière, Lyon',
            'Croix-Rousse, Lyon',
            'Gerland, Lyon'
        ];

        for (let i = 0; i < 50; i++) {
            // Random location
            const location = locations[Math.floor(Math.random() * locations.length)];

            // Random date within the last 30 days
            const randomDate = new Date(today);
            randomDate.setDate(today.getDate() - Math.floor(Math.random() * 30));
            const formattedDate = randomDate.toISOString().split('T')[0];

            // Random annotation
            const annotation = Math.random() < 0.5 ? 'Pleine' : 'Vide';

            history.push({
                annotation: annotation,
                location: location,
                date: formattedDate,
                imagePath: '', // No image
                status: 'processing',
                label: annotation,
            });
        }

        sessionStorage.setItem('analysisHistory', JSON.stringify(history));
        alert('50 poubelles avec des localisations, annotations et dates aléatoires ajoutées à Lyon.');
    });
    function updateProcessingBinsTable() {
        const history = JSON.parse(sessionStorage.getItem("analysisHistory")) || [];
        const processingBins = history.filter(bin => bin.status === "processing");

        const tableBody = document.getElementById("processingBinsTable");
        tableBody.innerHTML = "";

        processingBins.forEach((bin, index) => {
            const row = document.createElement("tr");
            row.innerHTML = `
            <td><img src="${bin.imagePath || 'https://via.placeholder.com/40'}" class="thumbnail img-thumbnail"></td>
            <td>${bin.date}</td>
            <td>${bin.annotation}</td>
            <td>${bin.location}</td>
            <td>${bin.status}</td>
            <td><button class="btn btn-success btn-sm" onclick="resolveBin(${index})">✔</button></td>
        `;
            tableBody.appendChild(row);
        });
    }

    function resolveBin(index) {
        const history = JSON.parse(sessionStorage.getItem("analysisHistory")) || [];
        const processingBins = history.filter(bin => bin.status === "processing");

        const binToResolve = processingBins[index];
        const binIndex = history.findIndex(bin => bin === binToResolve);
        if (binIndex !== -1) {
            history[binIndex].status = "resolved";
            sessionStorage.setItem("analysisHistory", JSON.stringify(history));
            updateProcessingBinsTable();
        }
    }

    // On page load, initialize the processing bins table
    window.addEventListener("load", () => {
        updateProcessingBinsTable();
    });
    function updateResolvedBinsCount() {
        const history = JSON.parse(sessionStorage.getItem("analysisHistory")) || [];
        const resolvedBinsCount = history.filter(bin => bin.status === "resolved").length;
        document.getElementById("resolvedBinsCount").textContent = resolvedBinsCount;
    }

    // Call this function on page load and after resolving a bin
    window.addEventListener("load", updateResolvedBinsCount);

    function resolveBin(index) {
        const history = JSON.parse(sessionStorage.getItem("analysisHistory")) || [];
        const processingBins = history.filter(bin => bin.status === "processing");

        const binToResolve = processingBins[index];
        const binIndex = history.findIndex(bin => bin === binToResolve);
        if (binIndex !== -1) {
            history[binIndex].status = "resolved";
            sessionStorage.setItem("analysisHistory", JSON.stringify(history));
            updateProcessingBinsTable();
            updateResolvedBinsCount(); // Update the count after resolving
        }
    }

    let binsPieChartInstance = null;

    function updateBinsPieChart(filteredData = null) {
        const dataToUse = filteredData || JSON.parse(sessionStorage.getItem("analysisHistory")) || [];
        const pleineCount = dataToUse.filter(bin => bin.annotation === "Pleine").length;
        const videCount = dataToUse.filter(bin => bin.annotation === "Vide").length;

        const data = {
            labels: ["Pleine", "Vide"],
            datasets: [{
                data: [pleineCount, videCount],
                backgroundColor: ["#FF6384", "#36A2EB"],
                hoverBackgroundColor: ["#FF6384", "#36A2EB"]
            }]
        };

        const options = {
            responsive: true,
            plugins: {
                tooltip: { enabled: true },
                legend: { display: true, position: "bottom" }
            }
        };

        const ctx = document.getElementById("binsPieChart").getContext("2d");

        if (binsPieChartInstance) {
            binsPieChartInstance.destroy();
        }

        binsPieChartInstance = new Chart(ctx, {
            type: "pie",
            data: data,
            options: options
        });
    }

    // Call this function on page load with no filter applied
    window.addEventListener("load", () => {
        updateBinsPieChart();
    });
</script>
</body>
</html>